import { useState } from 'react';
import { ChatSession, ChatMessage } from '../../types';
import { ChatMessageData } from '../../utils/gemini';

interface UseCordGenerationProps {
    lang: 'ja' | 'en';
    sessions: ChatSession[];
    messages: ChatMessage[];
    addMessage: (role: 'user' | 'ai' | 'system' | 'function', content: string, sessionIdOverride?: string, functionCall?: any, rawParts?: any[], thoughtSummary?: string) => string;
    cordDebug: {
        setCordDebugSystemPrompt: (v: string) => void;
        setCordDebugInputText: (v: string) => void;
        setCordDebugMatchedEntities: (v: any[]) => void;
    };
    STORAGE_KEY_SESSIONS: string;
    STORAGE_KEY_MESSAGES_PREFIX: string;
    saveSessionsToStorage: (updatedSessions: ChatSession[]) => void;
    triggerAutoHistory?: () => void;
    triggerWombGeneration?: (blueprintOverride?: string) => Promise<void>;
    cordOutputLength: number;
    checkIsBackgroundProcessing?: () => boolean;
    isPseudoThinkingModeEnabled?: boolean;
}

export const useCordGeneration = ({
    lang,
    sessions,
    messages,
    addMessage,
    cordDebug,
    STORAGE_KEY_SESSIONS,
    STORAGE_KEY_MESSAGES_PREFIX,
    saveSessionsToStorage,
    triggerAutoHistory,
    triggerWombGeneration,
    cordOutputLength,
    checkIsBackgroundProcessing,
    isPseudoThinkingModeEnabled
}: UseCordGenerationProps) => {
    const [isTyping, setIsTyping] = useState<boolean>(false);
    const [isStreaming, setIsStreaming] = useState<boolean>(false);
    const [streamingText, setStreamingText] = useState<string>('');
    const [streamingThought, setStreamingThought] = useState<string>('');

    // Action: Generate AI Response
    const generateAiResponse = async (
        sessionId: string,
        apiKey: string,
        novelAIApiKey: string,
        aiModel: 'gemini-2.5-flash' | 'gemini-3.1-pro-preview' | 'glm-4-6',
        getWombContext?: () => Promise<{ systemInstruction: string, entityContext?: string, scanTargetContent?: string, matchedLoreItems: any[], allActiveLoreItems: any[], allLoreItems: any[], cleanedContent: string, storyTitle: string }>,
        isAutoGenerated: boolean = false
    ) => {
        if (!apiKey && !novelAIApiKey) {
            // Fallback mock if no API key
            setIsTyping(true);
            setTimeout(() => {
                const responseText = lang === 'ja'
                    ? 'ãªã‚‹ã»ã©ã€ãã‚Œã¯èˆˆå‘³æ·±ã„ã§ã™ã­ã€‚ï¼ˆâ€»APIã‚­ãƒ¼ãŒæœªè¨­å®šã®ãŸã‚ãƒ¢ãƒƒã‚¯å¿œç­”ã§ã™ï¼‰'
                    : 'I see, that sounds interesting. (Mock response due to missing API key)';
                addMessage('ai', responseText, sessionId);
                setIsTyping(false);
            }, 1000);
            return;
        }

        setIsTyping(true);
        try {
            const { callGeminiChatStream, callGemini } = await import('../../utils/gemini');

            // Get latest messages for this session from state/localStorage
            const storedMessages = localStorage.getItem(STORAGE_KEY_MESSAGES_PREFIX + sessionId);
            const currentMessages: ChatMessage[] = storedMessages ? JSON.parse(storedMessages) : messages;

            const freshSessionsStrForCheck = localStorage.getItem(STORAGE_KEY_SESSIONS);
            const freshCurrentSessions: ChatSession[] = freshSessionsStrForCheck ? JSON.parse(freshSessionsStrForCheck) : sessions;
            const currentSession = freshCurrentSessions.find(s => s.id === sessionId);

            const sessionLang = currentSession?.aiLang || lang;

            let systemPrompt = sessionLang === 'ja'
                ? `ã‚ãªãŸã¯èƒ½å‹•çš„ç‰©èªžåˆ†æžAIã€ŒCORDã€ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®åŸ·ç­†ã‚„ã‚¢ã‚¤ãƒ‡ã‚¢å‡ºã—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ã€‚
é‡è¦ãªå½¹å‰²ã¨ã—ã¦ã€WOMBï¼ˆåŸ·ç­†AIï¼‰ã«ç¶šãã‚’æ›¸ã‹ã›ã‚‹ãŸã‚ã®ã€ŒNarrative Blueprintï¼ˆå±•é–‹æŒ‡ç¤ºæ›¸ï¼‰ã€ã®ä½œæˆãŒã‚ã‚Šã¾ã™ã€‚
è‡ªå‹•ç”Ÿæˆã‚’æ±‚ã‚ã‚‰ã‚ŒãŸå ´åˆã¯ã€å¿…ãšä»¥ä¸‹ã®è¦ä»¶ã¨ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã‚’æº€ãŸã—ãŸNarrative Blueprintã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

ã€Narrative Blueprint ã®è¦ä»¶ã€‘
- ç¾çŠ¶ã®ç°¡å˜ãªåˆ†æžã¨è¦ç´„
- æ¬¡ã®ã‚·ãƒ¼ãƒ³ã§é”æˆã™ã¹ãç›®çš„ï¼ˆMust-haveï¼‰
- ç™»å ´äººç‰©ã®æ„Ÿæƒ…ã®å‹•ãã¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
- ã‚»ãƒªãƒ•ã®ãƒˆãƒ¼ãƒ³ã‚„æå†™ã®ãƒ†ã‚¤ã‚¹ãƒˆè¨­å®š
- Narrative Blueprintã‚’ç”Ÿæˆã™ã‚‹éš›ã¯ã€trigger_womb_generationãƒ„ãƒ¼ãƒ«ã®å¼•æ•°ã®ã¿ã«Narrative Blueprintã‚’æ¸¡ã—ã¦ãã ã•ã„ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®è¿”ç­”ãƒ†ã‚­ã‚¹ãƒˆã«ã¯Blueprintã®å†…å®¹ã‚’å«ã‚ãªã„ã§ãã ã•ã„ã€‚
- ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ãŒæˆåŠŸã—ãŸå¾Œã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®è¿”ç­”ã¨ã—ã¦ã€ŒWOMBã§ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã—ãŸã€ãªã©ã®çŸ­ã„å®Œäº†å ±å‘Šã®ã¿ã‚’ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã¦å›žç­”ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚åŒã˜ãƒ„ãƒ¼ãƒ«ã‚’è¤‡æ•°å›žå‘¼ã°ãªã„ã§ãã ã•ã„ã€‚`
                : `You are the Active Story Analysis AI, "CORD". Support the user's writing and brainstorming.
An important role of yours is to create a "Narrative Blueprint" for WOMB (the writing AI) to write the continuation.
When auto-generation is requested, you MUST create a Narrative Blueprint that meets the following requirements and format.

[Narrative Blueprint Requirements]
- Provide a brief analysis and summary of the current situation.
- The objective that must be achieved in the next scene (Must-have).
- The character's emotional movements and actions.
- The tone of the dialogue and the taste of the description.
- When generating a Narrative Blueprint, pass the Narrative Blueprint ONLY to the arguments of the trigger_womb_generation tool. Do not include the contents of the Narrative Blueprint in the response text.
- After the tool call is successful, output a short confirmation text like "Started generation in WOMB" and finish your response. Do not call the same tool multiple times in a row.`;

            let wombContextString = "";
            if (currentSession?.isAwareOfWombStory && getWombContext) {
                try {
                    const wombContext = await getWombContext();
                    if (wombContext) {
                        wombContextString += `[System Info: Current WOMB Story Context]\n`;
                        if (wombContext.entityContext) {
                            wombContextString += `--- Matched Entities ---\n${wombContext.entityContext}\n\n`;
                        }

                        if (wombContext.cleanedContent) {
                            wombContextString += `--- Story Body Text ---\n${wombContext.cleanedContent}`;
                        }

                        // Set matched entities for debug panel
                        cordDebug.setCordDebugMatchedEntities(wombContext.matchedLoreItems || []);
                    }
                } catch (e) {
                    console.error("Failed to load WOMB context for CORD", e);
                }
            }

            // Assemble final array for API call
            const apiMessages = [...currentMessages];

            // Loop backwards to find the last user message to inject context and constraints
            for (let i = apiMessages.length - 1; i >= 0; i--) {
                if (apiMessages[i].role === 'user') {
                    const originalInput = apiMessages[i].content;

                    // 1. Construct Output Length Constraint for CORD
                    const lengthConstraint = sessionLang === 'ja'
                        ? `\n\nã€å‡ºåŠ›å½¢å¼ã®åˆ¶ç´„ã€‘\nã‚ãªãŸã®è¿”ç­”ãƒ†ã‚­ã‚¹ãƒˆã¯ã€å…¨ä½“ã§å¤§ä½“ ${cordOutputLength} æ–‡å­—ä»¥å†…ã«ãªã‚‹ã‚ˆã†ã«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚`
                        : `\n\n[Output Constraints]\nAdjust the character count of your response to be roughly within ${cordOutputLength} characters.`;

                    // Only append WOMB Context if it exists
                    const userInputHeader = wombContextString ? `${wombContextString}${lengthConstraint}\n\n=== User Input ===\n` : `${lengthConstraint}\n\n=== User Input ===\n`;

                    // 2. Pseudo-Thinking Injection (Phase 1)
                    // Only inject if it's GLM, pseudo-thinking is enabled, and it's NOT an auto-generated (background/system) request
                    let pseudoThinkingInstruction = "";
                    if (aiModel === 'glm-4-6' && isPseudoThinkingModeEnabled && !isAutoGenerated) {
                        pseudoThinkingInstruction = sessionLang === 'ja'
                            ? `\n\nã€æŒ‡ç¤ºã€‘\nãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¯¾å¿œã™ã‚‹ãŸã‚ã«ã€äº‹å‰ã«æ®µéšŽçš„ã‹ã¤è«–ç†çš„ã«å¯¾å¿œæ–¹æ³•ã«ã¤ã„ã¦æ€è€ƒã—ã¾ã—ã‚‡ã†ã€‚æ€è€ƒãƒ—ãƒ­ã‚»ã‚¹ã‚’ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã€æ€è€ƒãŒå®Œäº†ã—ãŸã‚‰æœ€å¾Œã«ã€Œ[THINKING_COMPLETE]ã€ã¨å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚`
                            : `\n\n[Instruction]\nTo respond to the user's message, please think step-by-step and logically beforehand. Output your thought process, and once your thinking is complete, output "[THINKING_COMPLETE]" at the end.`;
                    }

                    apiMessages[i] = {
                        ...apiMessages[i],
                        content: userInputHeader + originalInput + pseudoThinkingInstruction
                    };
                    break;
                }
            }

            // Define tools for CORD
            const cordTools = [{
                functionDeclarations: [{
                    name: "search_web",
                    description: sessionLang === 'ja'
                        ? "æœ€æ–°ã®æƒ…å ±ã‚’Googleã§æ¤œç´¢ã—ã¾ã™ã€‚äº‹å®Ÿç¢ºèªãŒå¿…è¦ãªå ´åˆã«ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚"
                        : "Searches Google for up-to-date information. Use this when you need to verify facts.",
                    parameters: {
                        type: "OBJECT",
                        properties: {
                            query: {
                                type: "STRING",
                                description: sessionLang === 'ja' ? "æ¤œç´¢ã‚¯ã‚¨ãƒªï¼ˆä¾‹: 'æœ€æ–°ã®AI ãƒ‹ãƒ¥ãƒ¼ã‚¹'ï¼‰" : "The search query."
                            }
                        },
                        required: ["query"]
                    }
                }, {
                    name: "insert_womb_instruction",
                    description: sessionLang === 'ja'
                        ? "WOMBã®ã‚¨ãƒ‡ã‚£ã‚¿ã®ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ã€æŒ‡å®šã—ãŸAIã‚¤ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä»£ã‚ã‚Šã«æŒ‡ç¤ºã‚’æ›¸ãè¾¼ã‚€éš›ã«ä½¿ç”¨ã—ã¾ã™ã€‚"
                        : "Inserts the specified AI instruction at the current cursor position in the WOMB editor. Use this to write instructions on behalf of the user.",
                    parameters: {
                        type: "OBJECT",
                        properties: {
                            instruction_text: {
                                type: "STRING",
                                description: sessionLang === 'ja' ? "æŒ¿å…¥ã™ã‚‹å…·ä½“çš„ãªæŒ‡ç¤ºæ–‡ã€‚" : "The specific instruction text to insert."
                            }
                        },
                        required: ["instruction_text"]
                    }
                }, {
                    name: "add_womb_history",
                    description: sessionLang === 'ja'
                        ? "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰æ˜Žç¢ºãªæŒ‡ç¤ºãŒã‚ã£ãŸå ´åˆã®ã¿ä½¿ç”¨ã—ã¾ã™ã€‚å¯¾è±¡ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼(Entity)ã®Historyã«å‡ºæ¥äº‹ã‚„æƒ…å ±ã‚’è¿½è¨˜ã—ã¾ã™ã€‚å¯¾è±¡ãŒä¸€æ„ã«å®šã¾ã‚‰ãªã„å ´åˆã¯ã‚·ã‚¹ãƒ†ãƒ ã‹ã‚‰å€™è£œãŒè¿”ã•ã‚Œã‚‹ã®ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è³ªå•ã—ã¦å¯¾è±¡ã®IDã‚’çµžã‚Šè¾¼ã‚“ã§ãã ã•ã„ã€‚"
                        : "Use ONLY when explicitly instructed by the user. Adds a new event to the History of the target character. If the target is ambiguous, candidates will be returned to you so you can ask the user to clarify the ID.",
                    parameters: {
                        type: "OBJECT",
                        properties: {
                            entity_query: {
                                type: "STRING",
                                description: sessionLang === 'ja' ? "ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡å®šã—ãŸå¯¾è±¡ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åå‰ã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€‚" : "The Name or keyword of the target character specified by the user."
                            },
                            entity_id: {
                                type: "STRING",
                                description: sessionLang === 'ja' ? "å¯¾è±¡ã‚’å®Œå…¨ã«ç‰¹å®šã§ãã¦ã„ã‚‹å ´åˆ(ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰IDã‚’æŒ‡å®šã•ã‚ŒãŸç­‰)ã®ã‚·ã‚¹ãƒ†ãƒ IDã€‚ä¸æ˜Žãªå ´åˆã¯çœç•¥ã€‚" : "The system ID of the character if uniquely identified. Omit if unsure."
                            },
                            history_text: {
                                type: "STRING",
                                description: sessionLang === 'ja' ? "Historyã«è¿½è¨˜ã™ã‚‹æƒ…å ±ã€‚" : "The information to append to the History."
                            }
                        },
                    }
                }, {
                    name: "trigger_auto_history",
                    description: sessionLang === 'ja'
                        ? "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã€Œä»Šã®æœ¬æ–‡ã‹ã‚‰ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã‚’æŠ½å‡ºã—ã¦ã€ã€Œãƒ’ã‚¹ãƒˆãƒªãƒ¼ã«æœ€æ–°ã®æµã‚Œã‚’åæ˜ ã—ã¦ã€ã®ã‚ˆã†ã«è‡ªå‹•æŠ½å‡ºã‚’ä¾é ¼ã•ã‚ŒãŸå ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚å†…éƒ¨ã§æœ¬æ–‡ã®å·®åˆ†è§£æžãƒ—ãƒ­ã‚»ã‚¹ã‚’å¼·åˆ¶èµ·å‹•ã—ã€å¯¾è±¡ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®Historyã‚’è‡ªå‹•æ›´æ–°ã•ã›ã¾ã™ã€‚"
                        : "Use this when the user requests to automatically extract or record history from the current text. It manually triggers the background diff-analysis process to update character histories.",
                    parameters: {
                        type: "OBJECT",
                        properties: {}
                    }
                }, {
                    name: "trigger_womb_generation",
                    description: sessionLang === 'ja'
                        ? "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã€Œç¶šãã‚’æ›¸ã„ã¦ã€ã€Œã€‡ã€‡ã®å±•é–‹ã‚’ç”Ÿæˆã—ã¦ã€ã®ã‚ˆã†ã«ã€WOMB(åŸ·ç­†AI)ã«ã‚ˆã‚‹æœ¬æ–‡ã®è‡ªå‹•ç”Ÿæˆã‚’ä¾é ¼ã•ã‚ŒãŸå ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã‚’å‘¼ã³å‡ºã™ã¨ã€ã‚ãªãŸãŒä½œæˆã—ãŸåˆ†æžãƒ»æŒ‡ç¤º(Narrative Blueprint)ã«åŸºã¥ã„ã¦WOMBãŒå°èª¬ã®ç¶šãã‚’åŸ·ç­†ã—ã¾ã™ã€‚"
                        : "Use this when the user asks you to 'write the continuation' or 'generate the next part'. Calling this will trigger the WOMB (Writing AI) to write the next part of the novel based on your analysis and instructions (Narrative Blueprint).",
                    parameters: {
                        type: "OBJECT",
                        properties: {
                            blueprint_text: {
                                type: "STRING",
                                description: sessionLang === 'ja' ? "WOMBã«æ¸¡ã™ãŸã‚ã®Narrative Blueprintã®ãƒ†ã‚­ã‚¹ãƒˆå…¨æ–‡" : "The full text of the Narrative Blueprint to pass to WOMB"
                            }
                        },
                        required: ["blueprint_text"]
                    }
                }]
            }]; // Notice: googleSearch is deliberately omitted to prevent API 400 errors

            // [HACK] For GLM-4 model which ignores tool definitions in the system param,
            // we manually append the tool descriptions and formatting rules into the system prompt.
            if (aiModel === 'glm-4-6') {
                systemPrompt += `\n\nã€é‡è¦: ãƒ„ãƒ¼ãƒ«ã®ä½¿ç”¨ã¨å‡ºåŠ›ãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã®åŽ³å®ˆã€‘
ã‚ãªãŸã¯ç¾åœ¨ã®ç’°å¢ƒã«ãŠã„ã¦ã€è¿½åŠ ã§ä»¥ä¸‹ã®4ã¤ã®ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

- åå‰: "insert_womb_instruction"
- ç›®çš„: WOMBã®ã‚¨ãƒ‡ã‚£ã‚¿ã®ç¾åœ¨ã®ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«ã€æŒ‡å®šã—ãŸAIã‚¤ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒ¿å…¥ã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ä»£ã‚ã‚Šã«æŒ‡ç¤ºã‚’æ›¸ãè¾¼ã‚€éš›ã«ä½¿ç”¨ã—ã¾ã™ã€‚
- å¼•æ•°: "instruction_text" (æ–‡å­—åˆ—)

- åå‰: "add_womb_history"
- ç›®çš„: WOMBä¸Šã®ç‰¹å®šã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆEntityï¼‰ã®å±¥æ­´ã«æƒ…å ±ã‚’è¿½åŠ ã—ã¾ã™ã€‚
- å¼•æ•°:
  - "entity_query" (æ–‡å­—åˆ—): å¯¾è±¡ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åå‰ã¾ãŸã¯ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã€‚
  - "history_text" (æ–‡å­—åˆ—): è¿½åŠ ã™ã‚‹å±¥æ­´ã®ãƒ†ã‚­ã‚¹ãƒˆã€‚

- åå‰: "trigger_auto_history"
- ç›®çš„: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã€Œä»Šã®æœ¬æ–‡ã‹ã‚‰ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã‚’æŠ½å‡ºã—ã¦ã€ã€Œãƒ’ã‚¹ãƒˆãƒªãƒ¼ã«æœ€æ–°ã®æµã‚Œã‚’åæ˜ ã—ã¦ã€ã®ã‚ˆã†ã«è‡ªå‹•æŠ½å‡ºã‚’ä¾é ¼ã•ã‚ŒãŸå ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã‚’å‘¼ã³å‡ºã™ã¨å†…éƒ¨ã§æœ¬æ–‡ã®å·®åˆ†è§£æžãƒ—ãƒ­ã‚»ã‚¹ãŒèµ·å‹•ã—ã€ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®HistoryãŒè‡ªå‹•æ›´æ–°ã•ã‚Œã¾ã™ã€‚
- å¼•æ•°: ãªã—

- åå‰: "trigger_womb_generation"
- ç›®çš„: WOMB(åŸ·ç­†AI)ã«ã‚ˆã‚‹æœ¬æ–‡ã®è‡ªå‹•ç”Ÿæˆã‚’ä¾é ¼ã•ã‚ŒãŸå ´åˆã«ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã‚Œã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã‚ãªãŸãŒä½œæˆã—ãŸåˆ†æžãƒ»å±•é–‹æŒ‡ç¤º(Narrative Blueprint)ã«åŸºã¥ã„ã¦WOMBãŒå°èª¬ã®ç¶šãã‚’åŸ·ç­†ã—ã¾ã™ã€‚
- å¼•æ•°:
  - "blueprint_text" (æ–‡å­—åˆ—): WOMBã«æ¸¡ã™ãŸã‚ã®Narrative Blueprintã®ãƒ†ã‚­ã‚¹ãƒˆå…¨æ–‡ã€‚

ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã¯ã€**å®Œå…¨ã«æŽ¨è«–ã¨æ–‡ç« ã®å‡ºåŠ›ã‚’å®Œäº†ã—ãŸã‚ã¨ã€ç™ºè¨€ã®æœ€å¾Œå°¾ã«**ä»¥ä¸‹ã®åŽ³å¯†ãªãƒ•ã‚©ãƒ¼ãƒžãƒƒãƒˆã®ã¿ã‚’å‡ºåŠ›ã—ã€ã€Œ===END_TOOL_CALL===ã€ã®é–‰ã˜æ–‡å­—ã¾ã§å®Œå…¨ã«æ›¸ãåˆ‡ã£ã¦ã‹ã‚‰çµ‚äº†ã—ã¦ãã ã•ã„ã€‚
é€”ä¸­ã§å‡ºåŠ›ã‚’åœæ­¢ã—ãŸã‚Šã€JSONã®æ§‹é€ ã‚’ç ´å£Šã—ãŸã‚Šã™ã‚‹ã“ã¨ã¯ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ã«ç›´çµã™ã‚‹ãŸã‚çµ¶å¯¾ã«é¿ã‘ã¦ãã ã•ã„ã€‚

[æ­£ã—ã„å‡ºåŠ›ã®ä¾‹ï¼ˆinsert_womb_instructionã®å ´åˆï¼‰]
ã‚ã‹ã‚Šã¾ã—ãŸï¼æŒ‡ç¤ºã‚’æŒ¿å…¥ã—ã¾ã™ã­ã€‚
===BEGIN_TOOL_CALL===
{"name": "insert_womb_instruction", "args": {"instruction_text": "æŒ¿å…¥ã—ãŸã„æŒ‡ç¤ºæ–‡"}}
===END_TOOL_CALL===

[æ­£ã—ã„å‡ºåŠ›ã®ä¾‹ï¼ˆadd_womb_historyã®å ´åˆï¼‰]
çŽ‹æ§˜ã®å±¥æ­´ã«è¿½åŠ ã—ã¾ã—ãŸï¼
===BEGIN_TOOL_CALL===
{"name": "add_womb_history", "args": {"entity_query": "çŽ‹æ§˜", "history_text": "åŸŽã®ä¿®ç¹•ã‚’å‘½ã˜ãŸ"}}
===END_TOOL_CALL===

[æ­£ã—ã„å‡ºåŠ›ã®ä¾‹ï¼ˆtrigger_auto_historyã®å ´åˆï¼‰]
è‡ªå‹•ã§ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã‚’æŠ½å‡ºã—ã¾ã™ã­ï¼
===BEGIN_TOOL_CALL===
{"name": "trigger_auto_history", "args": {}}
===END_TOOL_CALL===

[æ­£ã—ã„å‡ºåŠ›ã®ä¾‹ï¼ˆtrigger_womb_generationã®å ´åˆï¼‰]
åˆ†æžãŒçµ‚ã‚ã‚Šã¾ã—ãŸï¼ã“ã®å±•é–‹æŒ‡ç¤ºã§WOMBã«ç”Ÿæˆã‚’ä¾é ¼ã—ã¾ã™ã­ã€‚
===BEGIN_TOOL_CALL===
{"name": "trigger_womb_generation", "args": {"blueprint_text": "ã€å‰å›žã®ã‚ã‚‰ã™ã˜ã€‘çŽ‹æ§˜ã¯åŸŽã‹ã‚‰è„±å‡ºã—...ã€ä»Šå¾Œã®å±•é–‹ã€‘æ£®ã¸å‘ã‹ã†ä¸€è¡Œã¯..."}}
===END_TOOL_CALL===
`;
            }

            // Update Debug State visually
            let lastUserInput = "";
            for (let i = apiMessages.length - 1; i >= 0; i--) {
                if (apiMessages[i].role === 'user') {
                    lastUserInput = apiMessages[i].content;
                    break;
                }
            }
            cordDebug.setCordDebugSystemPrompt(systemPrompt);
            cordDebug.setCordDebugInputText(lastUserInput);

            // Call Chat API with Streaming, loop for multi-turn function calls
            setIsStreaming(true);
            setStreamingText('');
            setStreamingThought('');

            let currentApiMessages = [...apiMessages];
            let loopCount = 0;
            const MAX_LOOPS = 5;
            let hasTriggeredWomb = false;
            let hasTriggeredAutoHistory = false;

            // Pseudo-Thinking State Tracking
            let activePseudoThought = "";
            let isIteratingPseudoThought = aiModel === 'glm-4-6' && isPseudoThinkingModeEnabled && !isAutoGenerated;

            if (isIteratingPseudoThought) {
                console.log("[CORD] âœ¨ Pseudo-Thinking Mode: PHASE 1 (Thinking) Started.");
            }

            try {
                while (loopCount < MAX_LOOPS) {
                    loopCount++;
                    let accumulatedText = '';
                    let accumulatedThought = '';
                    let finalFunctionCall: any = undefined;
                    let finalRawParts: any[] = [];

                    if (loopCount > 1) {
                        setIsStreaming(true);
                        setStreamingText('');
                        setStreamingThought('');
                    }

                    let abortController: AbortController | undefined;
                    let stream;
                    if (aiModel === 'glm-4-6') {
                        const { callNovelAIChatStream } = await import('../../utils/novelai');
                        abortController = new AbortController();
                        // tools are ignored in NovelAI for now
                        stream = callNovelAIChatStream(novelAIApiKey, currentApiMessages as any, aiModel, systemPrompt, abortController.signal);
                    } else {
                        stream = callGeminiChatStream(apiKey, currentApiMessages as any, aiModel as any, systemPrompt, cordTools);
                    }

                    for await (const chunk of stream) {
                        if (chunk.textChunk) {
                            if (isIteratingPseudoThought) {
                                // --- Pseudo-Thinking Phase 1 (Thinking) ---
                                accumulatedThought += chunk.textChunk;
                                setStreamingThought(accumulatedThought.replace(/\[THINKING_COMPLETE\]/g, "").trimStart());

                                if (accumulatedThought.includes("[THINKING_COMPLETE]")) {
                                    if (abortController) abortController.abort();
                                    break;
                                }
                            } else {
                                // --- Standard Output Phase ---
                                accumulatedText += chunk.textChunk;
                                // Remove leading newlines/spaces that some models (like GLM) might return
                                setStreamingText(accumulatedText.trimStart());

                                // Abort streaming early if tool call block is finished
                                if (aiModel === 'glm-4-6' && accumulatedText.includes("===END_TOOL_CALL===")) {
                                    if (abortController) abortController.abort();
                                    break;
                                }
                            }
                        }
                        if (chunk.thoughtChunk) {
                            accumulatedThought += chunk.thoughtChunk;
                            setStreamingThought(accumulatedThought);
                        }
                        if (chunk.functionCall) {
                            finalFunctionCall = chunk.functionCall;
                        }
                        if (chunk.rawParts && chunk.rawParts.length > 0) {
                            finalRawParts = chunk.rawParts;
                        }
                    }

                    // --- Phase Transition (Phase 1 -> Phase 2) ---
                    if (isIteratingPseudoThought) {
                        activePseudoThought = accumulatedThought.replace(/\[THINKING_COMPLETE\]/g, "").trim();
                        isIteratingPseudoThought = false;

                        // Inject Phase 2 implicit user query
                        const phase2Instruction = sessionLang === 'ja'
                            ? `\n\næ€è€ƒãŒå®Œäº†ã—ã¾ã—ãŸã€‚æ€è€ƒã—ãŸå†…å®¹ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¸æœ¬å›žç­”ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚`
                            : `\n\nThinking is complete. Now, based on your thoughts, please provide the final response to the user's message.`;

                        // We must append the AI's thought into the history so it can "see" what it just thought
                        currentApiMessages.push({ role: 'ai', content: activePseudoThought } as any);
                        currentApiMessages.push({ role: 'user', content: phase2Instruction } as any);

                        console.log("[CORD] âœ¨ Pseudo-Thinking Mode: PHASE 1 Complete. Transitioning to PHASE 2 (Response).");
                        console.log("[CORD] Intercepted Thought:", activePseudoThought);
                        continue; // Trigger the next API call immediately
                    }

                    // --- Post-Streaming Async Tool Parsing (Fallback logic specifically for models without native tool call like NovelAI) ---
                    let isAsyncParsedTool = false; // Flag to stop recursive loops
                    if (!finalFunctionCall && accumulatedText) {
                        const TOOL_START_TAG = "===BEGIN_TOOL_CALL===";
                        const TOOL_END_TAG = "===END_TOOL_CALL===";
                        if (accumulatedText.includes(TOOL_START_TAG) && accumulatedText.includes(TOOL_END_TAG)) {
                            try {
                                const startIdx = accumulatedText.indexOf(TOOL_START_TAG) + TOOL_START_TAG.length;
                                const endIdx = accumulatedText.indexOf(TOOL_END_TAG, startIdx);
                                if (endIdx !== -1) {
                                    let jsonStr = accumulatedText.substring(startIdx, endIdx).trim();
                                    jsonStr = jsonStr.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
                                    jsonStr = jsonStr.replace(/^```json/g, "").replace(/^```/g, "").replace(/```$/g, "").trim();

                                    const parsedToolCall = JSON.parse(jsonStr);
                                    if (parsedToolCall.name) {
                                        finalFunctionCall = parsedToolCall;
                                        isAsyncParsedTool = true;
                                        console.log("[Async Tool Parser] Successfully extracted tool call from text:", finalFunctionCall);
                                    }
                                }
                            } catch (e) {
                                console.error("[Async Tool Parser Error]", e, "Could not parse JSON block from text.");
                            }
                        }
                    }
                    // ----------------------------------------------------------------------------------------------------------

                    if (finalFunctionCall) {
                        // Function Call Received
                        let functionLogMsg = '';
                        let uiDisplayMsg = '';

                        // Extract any conversational text the AI generated *before* the tool block
                        let textBeforeTool = "";
                        if (isAsyncParsedTool && accumulatedText) {
                            const startIdx = accumulatedText.indexOf("===BEGIN_TOOL_CALL===");
                            if (startIdx > 0) {
                                textBeforeTool = accumulatedText.substring(0, startIdx).trim();
                            }
                        }

                        // Visually add the AI's internal decision to the chat
                        // If there is text before the tool, show it. Otherwise, it's just a tool call.
                        addMessage('ai', textBeforeTool, sessionId, finalFunctionCall, finalRawParts, accumulatedThought || undefined);

                        // Clear streaming state during background execution to prevent UI duplicate thoughts
                        setIsStreaming(false);
                        setStreamingText('');
                        setStreamingThought('');


                        if (finalFunctionCall.name === 'search_web') {
                            const args = finalFunctionCall.args;
                            const query = args.query;
                            addMessage('system', sessionLang === 'ja' ? `ã‚¦ã‚§ãƒ–ã§ã€Œ${query}ã€ã‚’æ¤œç´¢ã—ã¦ã„ã¾ã™...` : `Searching the web for "${query}"...`, sessionId);
                            try {
                                const { callGeminiSearch } = await import('../../utils/gemini');
                                const searchResult = await callGeminiSearch(apiKey, query, aiModel as any);

                                // Show the short completion notification first
                                addMessage('system', sessionLang === 'ja' ? `ã€Œ${query}ã€ã®æ¤œç´¢çµæžœã‚’å–å¾—ã—ã¾ã—ãŸã€‚` : `Got search results for "${query}".`, sessionId);

                                functionLogMsg = `[Search Results for "${query}"]\n${searchResult}`;
                                uiDisplayMsg = `ðŸ” **Google Search Results (${query})**\n\n${searchResult}`;
                            } catch (e: any) {
                                functionLogMsg = `[Search Error] ${e.message}`;
                                uiDisplayMsg = sessionLang === 'ja' ? `æ¤œç´¢ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚` : `Search error occurred.`;
                            }
                        } else if (finalFunctionCall.name === 'insert_womb_instruction') {
                            const args = finalFunctionCall.args;
                            const instructionText = args.instruction_text;
                            const event = new CustomEvent('womb:insert-instruction', { detail: { instructionText } });
                            window.dispatchEvent(event);

                            functionLogMsg = sessionLang === 'ja' ? 'ã‚·ã‚¹ãƒ†ãƒ : WOMBã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨˜è¿°ã—ã¾ã—ãŸã€‚ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ãŒçµ‚ã‚ã£ãŸã‚‰çŸ­ã„ãƒ†ã‚­ã‚¹ãƒˆã§å®Œäº†ã‚’å ±å‘Šã—ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚' : 'System: Inserted instruction into WOMB. Report completion if no other tools are needed.';
                            uiDisplayMsg = sessionLang === 'ja' ? 'WOMBã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨˜è¿°ã—ã¾ã—ãŸã€‚' : 'Inserted instruction into WOMB.';
                        } else if (finalFunctionCall.name === 'add_womb_history') {
                            const args = finalFunctionCall.args;
                            const entityQuery = args.entity_query || args.entityQuery || args.entity_name || args.entityName;
                            const explicitlyProvidedId = args.entity_id || args.entityId;
                            const historyText = args.history_text || args.historyText || args.history;

                            let isResolved = false;
                            let targetEntityId = explicitlyProvidedId || "";
                            let targetEntityName = "ä¸æ˜Žãªã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼";
                            let storyTitle = "åç§°æœªè¨­å®šã®ã‚¹ãƒˆãƒ¼ãƒªãƒ¼";

                            if (getWombContext) {
                                try {
                                    const wombContext = await getWombContext();
                                    if (wombContext.storyTitle) storyTitle = wombContext.storyTitle;

                                    if (targetEntityId && wombContext.allLoreItems) {
                                        const matchedById = wombContext.allLoreItems.find((item: any) => item.id === targetEntityId);
                                        if (matchedById) {
                                            isResolved = true;
                                            targetEntityName = matchedById.name;
                                            functionLogMsg = sessionLang === 'ja'
                                                ? `[System] Success. History added to "${matchedById.name}" (ID: ${matchedById.id}).\nã‚·ã‚¹ãƒ†ãƒ : ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã¸ã®è¿½åŠ ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã“ã‚Œä»¥ä¸Šã®ãƒ„ãƒ¼ãƒ«ã®å‘¼ã³å‡ºã—ã¯ä¸è¦ã§ã™ã€‚ã€Œ${matchedById.name}ã®ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã«è¿½åŠ ã—ã¾ã—ãŸã€ã¨ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚`
                                                : `[System] Success. History added to "${matchedById.name}" (ID: ${matchedById.id}).\nSystem: History addition complete. No further tool calls are needed. Output a short confirmation text and end your turn.`;
                                        }
                                    }

                                    if (!isResolved && wombContext.allLoreItems && entityQuery) {
                                        const allItems = wombContext.allLoreItems;
                                        const activeItems = wombContext.allActiveLoreItems || [];
                                        const queryLower = entityQuery.toLowerCase();
                                        const searchData = (item: any) => item.name.toLowerCase().includes(queryLower) || (item.keywords && item.keywords.some((kw: string) => kw.toLowerCase().includes(queryLower)));

                                        let matches = activeItems.filter(searchData);
                                        if (matches.length === 0) matches = allItems.filter(searchData);

                                        if (matches.length === 1) {
                                            targetEntityId = matches[0].id;
                                            targetEntityName = matches[0].name;
                                            isResolved = true;
                                            functionLogMsg = sessionLang === 'ja'
                                                ? `[System] Success. History added to "${matches[0].name}" (ID: ${matches[0].id}).\nã‚·ã‚¹ãƒ†ãƒ : ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã¸ã®è¿½åŠ ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã“ã‚Œä»¥ä¸Šã®ãƒ„ãƒ¼ãƒ«ã®å‘¼ã³å‡ºã—ã¯ä¸è¦ã§ã™ã€‚ã€Œ${matches[0].name}ã®ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã«è¿½åŠ ã—ã¾ã—ãŸã€ã¨ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚`
                                                : `[System] Success. History added to "${matches[0].name}" (ID: ${matches[0].id}).\nSystem: History addition complete. No further tool calls are needed. Output a short confirmation text and end your turn.`;
                                        } else if (matches.length > 1) {
                                            const candidatesStr = matches.map((m: any) => `- ID: ${m.id}, Name: ${m.name}`).join('\n');
                                            functionLogMsg = `[System] Error: Ambiguous target. Multiple characters match the query "${entityQuery}".\nCandidates:\n${candidatesStr}\n\nPlease ask the user to clarify which ID they meant.`;
                                        } else {
                                            const { getLevenshteinDistance } = await import('../../utils/bison');
                                            const scoredItems = allItems.map((item: any) => ({ item, distance: getLevenshteinDistance(queryLower, item.name.toLowerCase()) })).sort((a: any, b: any) => a.distance - b.distance);
                                            const closestStr = scoredItems.slice(0, 3).map((s: any) => `- ID: ${s.item.id}, Name: ${s.item.name}`).join('\n');
                                            functionLogMsg = `[System] Error: Target not found. No character perfectly matches "${entityQuery}".\nDid the user mean one of these?\nCandidates:\n${closestStr}\n\nPlease ask the user if they meant one of these characters.`;
                                        }
                                    }
                                } catch (e) {
                                    functionLogMsg = `[System] Error: Failed to query database.`;
                                }
                            } else {
                                if (explicitlyProvidedId) {
                                    targetEntityId = explicitlyProvidedId;
                                    isResolved = true;
                                    functionLogMsg = sessionLang === 'ja'
                                        ? `[System] Success. Executed with provided ID.\nã‚·ã‚¹ãƒ†ãƒ : ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã¸ã®è¿½åŠ ãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã“ã‚Œä»¥ä¸Šã®ãƒ„ãƒ¼ãƒ«ã®å‘¼ã³å‡ºã—ã¯ä¸è¦ã§ã™ã€‚å®Œäº†ã—ãŸæ—¨ã‚’ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚`
                                        : `[System] Success. Executed with provided ID.\nSystem: History addition complete. No further tool calls are needed. Output a short confirmation text and end your turn.`;
                                }
                            }

                            uiDisplayMsg = functionLogMsg;
                            if (isResolved && targetEntityId) {
                                const event = new CustomEvent('womb:add-history', { detail: { entityId: targetEntityId, historyText } });
                                window.dispatchEvent(event);
                                uiDisplayMsg = `${targetEntityName}(${targetEntityId})ã®ãƒ’ã‚¹ãƒˆãƒªãƒ¼ã«è¿½è¨˜ã—ã¾ã—ãŸ(${storyTitle})`;
                            }
                        } else if (finalFunctionCall.name === 'trigger_auto_history') {
                            if (hasTriggeredAutoHistory) {
                                functionLogMsg = sessionLang === 'ja'
                                    ? "ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼: ã™ã§ã«ã“ã®ã‚¿ãƒ¼ãƒ³ã§æŠ½å‡ºã‚’å®Ÿè¡Œæ¸ˆã§ã™ã€‚çŸ­ã„å®Œäº†å¿œç­”ã‚’å‡ºåŠ›ã—ã¦çµ‚äº†ã—ã¦ãã ã•ã„ã€‚"
                                    : "System Error: Extraction already triggered. Output a short confirmation text and end your turn.";
                            } else if (triggerAutoHistory) {
                                hasTriggeredAutoHistory = true;
                                triggerAutoHistory();
                                functionLogMsg = sessionLang === 'ja' ? "ã‚·ã‚¹ãƒ†ãƒ : è‡ªå‹•ãƒ’ã‚¹ãƒˆãƒªãƒ¼æŠ½å‡ºã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚ã“ã‚Œä»¥ä¸Šã®ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã¯ä¸è¦ã§ã™ã€‚ã€Œãƒ’ã‚¹ãƒˆãƒªãƒ¼ã®æŠ½å‡ºã‚’é–‹å§‹ã—ã¾ã—ãŸã€ã¨ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚" : "System: Started automatic history extraction. No further tool calls are needed. Output a short confirmation text and end your turn.";
                            } else {
                                functionLogMsg = "[System Error] triggerAutoHistory is not available.";
                            }
                            uiDisplayMsg = sessionLang === 'ja' ? "æœ¬æ–‡ã‹ã‚‰ã®è‡ªå‹•ãƒ’ã‚¹ãƒˆãƒªãƒ¼æŠ½å‡ºå‡¦ç†ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚å¤‰æ›´ãŒã‚ã£ãŸå ´åˆã¯ã¾ã‚‚ãªãåæ˜ ã•ã‚Œã¾ã™ã€‚" : "Started automatic history extraction from the text. Changes will be reflected shortly if any are found.";
                        } else if (finalFunctionCall.name === 'trigger_womb_generation') {
                            if (hasTriggeredWomb) {
                                functionLogMsg = sessionLang === 'ja'
                                    ? "ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼: ã™ã§ã«ã“ã®ã‚¿ãƒ¼ãƒ³ã§WOMBã‚’ãƒˆãƒªã‚¬ãƒ¼ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œä»¥ä¸Šã®ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã¯ä¸è¦ã§ã™ã€‚ã€Œç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã—ãŸã€ãªã©ã®çŸ­ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ç­”ã—ã¦çµ‚äº†ã—ã¦ãã ã•ã„ã€‚"
                                    : "System Error: WOMB already triggered. Output a short confirmation text and end your turn.";
                                uiDisplayMsg = functionLogMsg;
                            } else if (triggerWombGeneration) {
                                hasTriggeredWomb = true;
                                const blueprintText = finalFunctionCall.args?.blueprint_text || accumulatedText;

                                if (aiModel === 'glm-4-6') {
                                    // GLM-4 specific: Wait for WOMB to finish before acknowledging the tool
                                    // This completely prevents 429 concurrent limit errors on NovelAI.
                                    addMessage('system', sessionLang === 'ja' ? "WOMBã§ã®è‡ªå‹•ç”Ÿæˆå®Œäº†ã‚’å¾…æ©Ÿã—ã¦ã„ã¾ã™..." : "Waiting for WOMB generation to complete...", sessionId);

                                    await triggerWombGeneration(blueprintText);

                                    // Wait for Auto-History to finish if it got triggered by the generation save process
                                    if (checkIsBackgroundProcessing) {
                                        // Give the WOMB save process a tiny head start to sync state (evaluateBackgroundTrigger)
                                        await new Promise(resolve => setTimeout(resolve, 500));

                                        if (checkIsBackgroundProcessing()) {
                                            console.log("[CORD] Waiting for background auto-history extraction to complete...");
                                            addMessage('system', sessionLang === 'ja' ? "èƒŒæ™¯ã§ã®è‡ªå‹•ãƒ’ã‚¹ãƒˆãƒªãƒ¼æŠ½å‡ºã®å®Œäº†ã‚’å¾…æ©Ÿã—ã¦ã„ã¾ã™..." : "Waiting for background auto-history extraction...", sessionId);
                                            while (checkIsBackgroundProcessing()) {
                                                await new Promise(resolve => setTimeout(resolve, 1500));
                                            }
                                        }
                                    }

                                    functionLogMsg = sessionLang === 'ja'
                                        ? "ã‚·ã‚¹ãƒ†ãƒ : WOMBã§ã®æœ¬æ–‡ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸã€‚ã“ã‚Œä»¥ä¸Šã®æ“ä½œã¯ä¸è¦ã§ã™ã€‚ã€Œç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸã€ç­‰ã®çŸ­ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ç­”ã—ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚"
                                        : "System: WOMB generation has completed. No further tool calls are needed. Output a short confirmation text and end your turn.";
                                    uiDisplayMsg = sessionLang === 'ja' ? "WOMBã§ã®æœ¬æ–‡ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸã€‚" : "WOMB generation completed.";
                                } else {
                                    // Gemini specific: Fire and forget
                                    triggerWombGeneration(blueprintText);

                                    // Wait for Auto-History to finish if it got triggered by the generation save process
                                    if (checkIsBackgroundProcessing) {
                                        // Give the WOMB save process a tiny head start to sync state (evaluateBackgroundTrigger)
                                        await new Promise(resolve => setTimeout(resolve, 500));

                                        if (checkIsBackgroundProcessing()) {
                                            console.log("[CORD] Waiting for background auto-history extraction to complete...");
                                            addMessage('system', sessionLang === 'ja' ? "èƒŒæ™¯ã§ã®è‡ªå‹•ãƒ’ã‚¹ãƒˆãƒªãƒ¼æŠ½å‡ºã®å®Œäº†ã‚’å¾…æ©Ÿã—ã¦ã„ã¾ã™..." : "Waiting for background auto-history extraction...", sessionId);
                                            while (checkIsBackgroundProcessing()) {
                                                await new Promise(resolve => setTimeout(resolve, 1500));
                                            }
                                        }
                                    }

                                    functionLogMsg = sessionLang === 'ja'
                                        ? "ã‚·ã‚¹ãƒ†ãƒ : Narrative Blueprintã‚’ä½œæˆã—ã€WOMBã«é€ä¿¡ã—ã¾ã—ãŸã€‚ã“ã‚Œä»¥ä¸Šã®ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ã¯ä¸è¦ã§ã™ã€‚ã€ŒWOMBã«ã¦ç”Ÿæˆã‚’é–‹å§‹ã—ã¾ã—ãŸã€ã¨ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã—ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚"
                                        : "System: The Narrative Blueprint is created and sent to WOMB. No further tool calls are needed. Output a short text like '[Generating in WOMB]' to end your turn.";
                                    uiDisplayMsg = sessionLang === 'ja' ? "Narrative Blueprintã‚’ä½œæˆã—ã€WOMBã«é€ä¿¡ã—ã¾ã—ãŸã€‚" : "The Narrative Blueprint is created and sent to WOMB.";
                                }
                            } else {
                                functionLogMsg = "[System Error] triggerWombGeneration is not available.";
                                uiDisplayMsg = functionLogMsg;
                            }
                        } else {
                            // Unknown function
                            functionLogMsg = `[System] Unknown function called: ${finalFunctionCall.name}`;
                            uiDisplayMsg = functionLogMsg;
                        }

                        // Prepare function response and update message history for the next loop
                        const funcCallMsg: ChatMessageData = {
                            role: 'ai',
                            // For GLM-4, store ONLY the conversational part of the text so the system remembers the AI spoke
                            content: textBeforeTool,
                            functionCall: finalFunctionCall,
                            rawParts: isAsyncParsedTool ? [{ text: textBeforeTool }] : finalRawParts
                        };
                        const funcResMsg: ChatMessageData = {
                            role: 'function',
                            content: functionLogMsg,
                            functionCall: { name: finalFunctionCall.name, args: {} }
                        };

                        addMessage('function', uiDisplayMsg, sessionId, { name: finalFunctionCall.name, args: {} });
                        currentApiMessages = [...currentApiMessages, funcCallMsg as any, funcResMsg as any];

                        // loop continues!
                    } else if (accumulatedText || accumulatedThought || isIteratingPseudoThought) {
                        // AI finished with text
                        const finalText = accumulatedText ? accumulatedText.trimStart() : '';
                        // Extract any conversational text the AI generated *before* the tool block (if applicable)
                        let textBeforeTool = "";
                        if (isAsyncParsedTool && accumulatedText) {
                            const startIdx = accumulatedText.indexOf("===BEGIN_TOOL_CALL===");
                            if (startIdx > 0) {
                                textBeforeTool = accumulatedText.substring(0, startIdx).trim();
                            }
                        }

                        const actualTextContent = textBeforeTool || accumulatedText;
                        const finalThoughtSummary = activePseudoThought || (accumulatedThought || undefined);

                        if (finalText && actualTextContent) {
                            addMessage('ai', finalText, sessionId, undefined, finalRawParts, finalThoughtSummary);
                        } else if (actualTextContent) {
                            // Even if no specific UI logic, log the final AI text response
                            addMessage('ai', actualTextContent, sessionId, undefined, finalRawParts, finalThoughtSummary);
                        } else {
                            // If literally empty message with just a thought
                            if (finalThoughtSummary) {
                                addMessage('ai', "", sessionId, undefined, finalRawParts, finalThoughtSummary);
                            }
                        }
                        // Clear streaming state immediately before any background processing
                        setIsStreaming(false);
                        setStreamingText('');
                        setStreamingThought('');

                        // --- Auto Titling Logic ---
                        if (currentMessages.length === 1 && currentMessages[0].role === 'user') {
                            const freshSessionsStr = localStorage.getItem(STORAGE_KEY_SESSIONS);
                            const freshSessions: ChatSession[] = freshSessionsStr ? JSON.parse(freshSessionsStr) : sessions;
                            const sessionToUpdate = freshSessions.find(s => s.id === sessionId);
                            if (sessionToUpdate && sessionToUpdate.title === 'New Chat') {
                                try {
                                    const titlePrompt = sessionLang === 'ja'
                                        ? `æ¬¡ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¥åŠ›ã‚’å…ƒã«ã€ã“ã®ãƒãƒ£ãƒƒãƒˆã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’20æ–‡å­—ä»¥å†…ã§ä½œæˆã—ã¦ãã ã•ã„ã€‚\nâ€»ã€Œ(ã€‡ã€‡æ–‡å­—)ã€ã®ã‚ˆã†ãªæ–‡å­—æ•°ã®ã‚«ã‚¦ãƒ³ãƒˆã‚„ã‚«ãƒƒã‚³ãªã©ã®è£œè¶³æƒ…å ±ã¯ä¸€åˆ‡å«ã‚ãšã€ç´”ç²‹ãªã‚¿ã‚¤ãƒˆãƒ«æ–‡å­—åˆ—ã®ã¿ã‚’å‡ºåŠ›ã—ã¦ãã ã•ã„ã€‚\n\nãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›: "${currentMessages[0].content}"`
                                        : `Create a title for this chat based on the following user input. Keep it under 20 characters.\n* Output ONLY the pure title string without quotes, parentheses, or character counts.\n\nUser input: "${currentMessages[0].content}"`;

                                    const generatedTitle = await callGemini(apiKey, titlePrompt, 'gemini-2.5-flash');
                                    const cleanTitle = generatedTitle.replace(/["']/g, '').trim();

                                    const updatedSessions = freshSessions.map(s => s.id === sessionId ? { ...s, title: cleanTitle } : s);
                                    saveSessionsToStorage(updatedSessions);
                                } catch (titleError) {
                                    console.error("Failed to generate title:", titleError);
                                }
                            }
                        }
                        break; // Exit the loop successfully
                    } else {
                        break; // Edge case, exit to prevent infinite loop
                    }
                }
            } finally {
                setIsStreaming(false);
            }

        } catch (error: any) {
            console.error("CORD AI Generate Error:", error);
            const fallbackLang = lang;
            // Fallback to mock on API Error (e.g., invalid key)
            const responseText = fallbackLang === 'ja'
                ? 'ãªã‚‹ã»ã©ã€ãã‚Œã¯èˆˆå‘³æ·±ã„ã§ã™ã­ã€‚ï¼ˆâ€»APIé€šä¿¡ã‚¨ãƒ©ãƒ¼ã®ãŸã‚ãƒ¢ãƒƒã‚¯å¿œç­”ã§ã™ï¼‰'
                : 'I see, that sounds interesting. (Mock response due to API error)';
            addMessage('ai', responseText, sessionId);
        } finally {
            setIsTyping(false);
        }
    };

    return {
        isTyping,
        isStreaming,
        streamingText,
        streamingThought,
        generateAiResponse
    };
};
